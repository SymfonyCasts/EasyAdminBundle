# Conditional Action

Okay, new goal. This page lists *all* of the questions on our site, and Pending Approval lists *only* those questions that are *not* approved. So ID 24 is not approved yet. We can also see that ID on the main Questions page. At the end of each row, you can see that *every* question has a delete link. I want to change this, so that only non-approved questions can be deleted, so I can, for instance, delete ID 24, but *not* delete ID 13 because it's an *approved* question. How do we do that? Since we're talking about questions, let's go to `QuestionCrudController.php`. The most obvious place is `configureActions`. After all, this is where we configure what actions our CRUD has, what links appear on which page, and what permissions you have.

In fact, you can even call `->disable()` and pass an action name to completely disable an action for your CRUD. *But*, that's not what we want to do here. We don't want to disable the "delete" action *everywhere*. We just want to disable it for *some* of our questions. To figure out how to do that, we need to talk more about these `Actions` and `action` objects. The `Actions` object is basically a container that says which actions should be on which page. So it knows that on our index page, we want to have a "Show" action, "Edit" action, and "Delete" action. And this object is actually created in our `DashboardController.php`. It *also* has `configureActions`. And if I jump into its parent method, you can see that it creates the actions and it sets up all the default actions for us. So `PAGE_INDEX` will have `NEW`, `EDIT`, and `DELETE`, and `PAGE_DETAIL` will have `EDIT`, `INDEX`, and `DELETE`. And we also added the `DETAIL` action to `PAGE_INDEX`. Notice that when we use the `->add()` function here, or when our parent controller uses the `->add()` function, it's just dealing with strings, basically passing the string `PAGE_INDEX`, and then `EDIT`. But when we do this, behind the scenes, EasyAdmin creates an `Action` object, which knows everything about how that action should look, including its label, CSS classes, and other stuff. So really, this `Action` object is a collection of information about each page and the `Action` objects they have on them. I'll jump into that class. As I mentioned, there's all kinds of things that you can configure on them, like it's label, icon, etc. It even has a method in here called `displayIf()` where we can dynamically control whether or not this action is displayed. The problem is that from inside of `configureActions`, what I want to do is be able to *get* the action for a page, like `->get(Crud::PAGE_INDEX, Action::DELETE`.

I also want to be able to *fetch* that `Action` object and then call `->displayIf()` on it. But this doesn't work. There's no way for me to access the `Action` object that represents the `DELETE` action on `PAGE_INDEX`. At first, that means the built-in actions that are made inside of our `DashboardController.php` are things we can't really modify. We can't change a CSS class or an icon on the built-in `Action` for `PAGE_INDEX`. *But* that's not really true. We *can* thanks to a nice function called `->update()`. Here, I can say `->update(Crud::PAGE_INDEX), Action::DELETE)`, and then pass it a callback that's going to receive an `Action` argument: `function(Action $action)`. Perfect! This now means that after the `DELETE` action is created on `PAGE_INDEX`, we want it passed to us so we can make changes. For now, we'll just `dd($action)`. If we go refresh, we'll see that dump on this page. Nice! You can see, inside of there, the `Action` object we expected, which has another `ActionDto` inside of it, where all the data is really held.

Now we can use the normal method, which is `$action->displayIf()`, and pass it a function. I'll make a `static function()` and pass it `Question $question`. The purpose of the `displayIf` is that each time the action is about to be displayed, like next to the first, second, or third question, it's going to call our function, pass us that `Question`, and we can decide whether or not that action should be shown. That's great! We can `return !$question->getIsApproved`.

All right, let's try it. Refresh and... error! 

```
Call to a member function getAsDto() on null
```

Oh, I always do this... For the `->update()` method, you actually need to *return* the action. There we go. Much better!

Now, if you look over here... look! The "Delete" action is gone! If you go down to ID 24, which is *not* approved, it's there! That's awesome! *But*, this isn't *quite* good enough. Right now, we're just *hiding* the link. If we really wanted this to work, we would also need to repeat the same thing on our details page, since our details page has a "Delete" link on it. I would need the same logic here to update the `DELETE` action on `PAGE_DETAIL`. But even *that* wouldn't be enough, because it would still allow someone to somehow get the URL to the "Delete" and use it. The "Delete" action itself is not secure - it doesn't truly *disable* the action. So to give us that extra layer of security, right before an entity is deleted, we can check to see if it's approved, and if it *is*, we'll throw an exception.

Real quick, I'm actually going to temporarily comment out this logic and `return true`, and then go back to the Questions page and... perfect! Delete is now showing up on everything. To test that security check idea, go to the bottom of `QuestionCrudController.php`. Before we override `updateEntity()`, this time we're going to override `deleteEntity()`, which will allow us to call code right *before* an entity is deleted. To help my entity, I'll document that entity is going to be an instance of question.

Now, `if ($entityInstance->getIsApproved())`, and then let's just `throw new \Exception('Deleting approved questions is forbidden')`. This is going to look like a 500 Error to the user. You could also throw an "access denied". Either way, this isn't a situation that anyone should have unless we have a bug in our code or a user is attempting to do something they shouldn't be able to.

So you can't delete an entity, and as long as we have all the actions configured so that `PAGE_INDEX` and `DETAIL` don't have the `DELETE` action, then this *should* work. But if we could *truly* disable the `DELETE` action conditionally on an entity-by-entity basis, then everything would work *a lot* simpler. EasyAdmin would know not to generate the "Delete" links in the right situations, and even if you guessed the URL, that wouldn't work either. How can we do that? We're going to need an event listener and some EasyAdmin internals. That's next.
