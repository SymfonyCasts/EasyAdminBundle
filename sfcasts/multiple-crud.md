# Multiple Crud

Right now, we have one CRUD controller per entity, but we can create *more* than one CRUD controller for the *same* entity. It's useful if you need to set up some filters behind the scenes and always apply them. For example, we're going to create a separate "Pending Approval" questions section that *only* lists questions that need to be approved. To do this, we're going to create a new CRUD controller, and instead of generating it this time, I'm going to create it by hand. Call it "QuestionPendingApprovalCrudController". We're creating it by hand because, instead of having an extended normal base class for a CRUD controller, we'll have it extend `QuestionCrudController.php`. That way, it inherits all of the normal `QuestionCrudController.php` syntax. Now, whenever we have a new CRUD controller, we need to link to it from our dashboard. Open `DashboardController.php`, duplicate this question here... say "Pending Approval"... and I'll tweak the icon slightly. If we stop now, you might be wondering, since both of these simply point to `Question` entity, how do they know to go to the correct controller? That actually *is* a problem. As soon as we have multiple CRUD controllers for the same entity, EasyAdmin is just going to *guess* the correct one to use,. To tell it explicitly, you can say `->setController()` and then pass it `QuestionPendingApprovalCrudController::class`. Do we need to set the controller on this other one to be safe? Absolutely. We'll do that in a few minutes.

All right, let's try it. Refresh. We get two links and they look absolutely identical, which makes sense. Now let's modify a query for this one to only show *non-approved* questions. We already know how to do that! Over in our new controller, I'm going to override a method called "createIndexQueryBuilder". And then we'll just modify this. Say `->andWhere()` and we know that our entity alias is called "entity", so `entity.isApproved` (as the field on our `Question` entity) `= :approved`, and then `->setParameter('approved')` set to `false`.

You can see we have a *bunch* of these right now. If we refresh, we go from a bunch to just *five*. It works! Except if you go to the original Question section, that *also* only shows five. As I mentioned, it's guessing the wrong CRUD controller. So in practice, as soon as you have multiple CRUD controllers for an entity, you should *always* specify the controller when you link to it. For this one, use `QuestionCrudControlle::class`. And if we head over and refresh this page... there's visually no difference. That' because we actually modified this link. If I click it, that will take me to the *correct* admin section.

All right, let's tweak a couple of things on our new CRUD controller. I'm going to override `configureCrud`. Most importantly, we need to `->setPageTitle()`. I'm going to set this up for the index page, so say `Crud::PAGE_INDEX` with "Questions pending approval". Now... that change is *much* more obvious.

When we're setting the page title, we can actually pass a callback if we want to use the question object itself in the name. So let's call `->setPageTitle()` again, and set *this* one up for the details page: `Crud::PAGE_DETAIL`. Then, instead of a string here, I'm going to pass a callback, `static function`, and that will receive the `Question` object as the first argument. Inside, we can return whatever we want, so I'll `return sprintf()` and let's put a little `#%s %s` and pass `$question->getId()` and `$question->getName()`. Nice! Let's try that. Head over to the show page for one of these quetions and... awesome! We now control a title with that dynamic data. And while we're here, the last thing I want to do is add a little "help" message on a specific page. We'll add it to our index page in case someone comes here and doesn't know what they're looking atm, with "Questions are not published to users until approved by a moderator".

If we refresh... our message shows up right here next to the title! Okay, there's one more subtle problem that having these two CRUD controllers has just created. To see that, jump into `AnswerCrudController.php`. One of the fields we have here is the `AssociationField` to `question`. Change this to `->autocomplete()`, which it should probably have since there's going to be *a lot* of questions in my database. If we look at our main Questions page here... this first question is *probably* an approved question. Now go to Answers. We'll Edit an answer... go down to the Question here... and now this uses autocomplete, which is cool, but if I paste that string, it says "No results found". The reason is subtle. If you go down to the web debug toolbar and open the profiler for one of those autocomplete AJAX requests, look at the URL closely. Part of the URL actually says "crudController = QuestionPendingApprovalCrudController".

When an autocomplete AJAX request is done for an entity (in this case, it's trying to autocomplete Question), that AJAX request is done *by* a CRUD controller. If you jump into `AbstractCrudController.php`, there's actually an `autocomplete` action. This is the action that's called to create the autocomplete response. It's done this way so that the autocomplete results can reuse your index query builder for the results. Unfortunately, just like with our dashboard, the autocomplete is guessing the wrong CRUD controller. It's going to `QuestionPendingApprovalCrudController.php`. To fix this, once again, we just need to be explicit. We can say `->setCrudController(QuestionCrudController::class)`. This time, I'll refresh... go down in Question, search for my string and... it finds it!

Next, what if we want to run some code before or after an entity is updated, created, or deleted? EasyAdmin has two solutions: Events and controller methods.
