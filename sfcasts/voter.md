# Voter

Thanks to `->setEntityPermission()`, EasyAdmin now runs *every* entity in this list through the security system, passing `ADMIN_USER_EDIT` for each one. If we're running this manually in a normal Symfony application, this would be the equivalent of running `$this->isGranted('ADMIN_USER_EDIT')`, where you pass the actual entity object - the `$user` object - as the second argument. Right now, when we do that, security always returns false because I just invented this `ADMIN_USER_EDIT` string. To run our custom security logic, we need a voter. Find your terminal and run:

```terminal
symfony console make:voter
```

I'll call it "AdminUserVoter". Perfect! Then we'll spin over and go to `/src/Security/Voter/AdminUserVoter.php`. I'm not going to talk *too* deeply about how voters work. We talk about those in our Symfony Security tutorial. But basically, the `supports` method here will be passed `ADMIN_USER_EDIT`, and then this is going to be the user object. We want to return true in that situation. So what I'll do here is check to see if the attribute is in an array with just `ADMIN_USER_EDIT`.

I don't really need `in_array` here anymore, but I'll keep it in case I add more attributes later, and they'll check to make sure that the subject is an `instanceof User`. Perfect! So if the security system calls supports and we return true from this method, we know that we are trying to decide or "vote" on our situation. In that case, the security system calls `voteOnAttribute()` and we simply need to return true or false based on whether or not the current user should have access to view this user object in the admin.

Once again, we're passed the `$attribute`, which will be `ADMIN_USER_EDIT` and this `$subject`, which will be the user object. To help my editor. add an extra "if" statement here: `if (!$subject instanceof User)`. Then `throw new \LogicException('Subject is not an instance of User?')`. This should never happen, but that will help my editor in any stack analysis. Finally, down here in the `switch` case (we only have one case right now), if that attribute is equal to `ADMIN_USER_EDIT`, then we want to allow access if `$user === $subject`. So if the currently authenticated user object - that's what this is here - is equal to the user object that we're asking about for security, then grant access. Otherwise, deny access. Symfony will instantly know to use our voter thanks to auto configuration. When we refresh... got it! We *just* see our one user and the message:

> Some results can't be displayed because you don't have
> enough permissions

Awesome! If you go down to the web debug toolbar, click this security icon, and then click "Access Decision", this shows you all the security decisions that were made in that request. And if you look, `ADMIN_USER_EDIT` was called multiple times. It was passed with this user - access was denied. It was passed with this user - that's us - and access was granted. It was passed with a different user - access denied. So you can see those security decisions being made in real time. The entity permissions are also enforced when you go to the details, edit, or delete pages. Again, if you go down to the web debug toolbar and click "Access Decision", down here... you can see it was checking for `ADMIN_USER_EDIT`.

This is great, except that super admin users should be able to see *all* users. Right now, no matter who I log in as, we're only going to show *that* user. To solve this, down in our logic, we can just check to see if the user has `ROLE_SUPER_ADMIN`. In order to do that, we're going to need a service. Add `public function __construct()`, and inject the security service from Symfony (I'll call it `$security`), hit "alt" + "enter", and go to "Initialize properties" to create that property and set it. And then, down here, we return true if `$user === $subject`, *or* if `$this->security->isGranted('ROLE_SUPER_ADMIN')`. Cool!

I won't bother logging in as a super admin to try this. You can, but if we *did* do that, we would see *every* user now. Okay, there's just one *tiny* problem with that. Imagine we have a lot of users in our database - like *thousands* - which is pretty realistic, and *our* user is ID 500. In that case, you would actually see *many* pages of results here. And our user *might* be on page 200. So you'd see no results on page one... or two... or three... until finally, on page 200, you'd find our *one* result. So it can get a little weird if you have *many* items in an admin section, and *many* of them are hidden.

To fix this, we can modify the query that's made for the index page to *only* return the users we want. This is totally optional, but can make for a better user experience. We haven't actually done this yet. So far, we're just letting EasyAdmin query for *every* user or *every* question. But we can *actually* have full control over that query. To do that, go into our `UserCrudController.php`, and it doesn't matter where - I'll go near the top - I'm going to override a method from the base controller called "createIndexQueryBuilder". Being able to override these methods is super powerful.

What happens here is the parent class starts the query builder for us. And it already takes into account things like the Search on top or the filters that we're going to talk about in a few minutes. Instead of returning that, I'll say `$queryBuilder =`, and then remember, if we're a super admin, we can see *everything*. So we're going to say `if $this->isGranted('ROLE_SUPER_ADMIN')`, then just `return $queryBuilder`, which is going to return every result. But if we *don't* have `ROLE_SUPER_ADMIN`, that's where we want to modify things. Say `$queryBuilder`, then `->andWhere()`. Inside the query, the alias for our entity is going to be called "entity", so say `entity.id = :id` and `->setParameter('id', $this->getUser()->getId())`. I don't get the auto complete on this because it thinks my user is just a user interface, but we know this is our user entity and we know it has a `getId()` method, so that will work. At the bottom, we'll `return $queryBuilder`. I guess I could have just returned right here, so let's just do that. Beautiful!

All right, let's try it! Spin over and... nice! Just our *one* result. And you don't see that message about results being hidden anymore due to security. That's because, *technically*, *none* of them were hidden due to security. They were just hidden due to our query. But the thing is, permissions are *still* being enforced. So if a user somehow got the edit URL to something they're not supposed to be able to see, the entity permissions are *still* going to deny that.

Next, we know that each CRUD section has a nice search box up here. Yay! But EasyAdmin *also* has a nice filter system where you can add more ways to slice and dice the data in each section.
